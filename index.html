<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DLR Timetable Explorer</title>
	<style>
		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			margin: 10px;
			background-color: #121212;
			color: #ffffff;
		}
		h1, h2, h3 {
			color: #ffffff;
			margin: 0;
			font-size: 1.2em;
		}
		button {
			background-color: #1e88e5;
			color: #ffffff;
			border: none;
			padding: 6px 10px;
			font-size: 14px;
			cursor: pointer;
			border-radius: 5px;
		}
		button:hover {
			background-color: #1565c0;
		}
		button:disabled {
			background-color: #455a64;
			cursor: not-allowed;
		}
		button.red-background {
			background-color: #e53935;
		}
		button.red-background:hover {
			background-color: #c62828;
		}
		#trainRunList {
			margin-bottom: 10px;
			border: 1px solid #424242;
			padding: 10px;
			border-radius: 5px;
			background-color: #1e1e1e;
			max-width: 800px;
			margin-left: auto;
			margin-right: auto;
		}
		#aboutText, #warningText {
			display: none;
			margin-top: 10px;
			background-color: #1e1e1e;
			padding: 10px;
			border-radius: 5px;
			border: 1px solid #424242;
		}
		#warningSection {
			display: none;
			margin-bottom: 10px;
			border: 1px solid #424242;
			padding: 10px;
			border-radius: 5px;
			background-color: #1c1121;
		}        
		#warningSection h2 {
			font-size: 1.2em;
			margin: 0 0 5px 0;
		}        
		.grid-container {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
			gap: 5px;
		}
		.run-number {
			cursor: pointer;
			color: #1e88e5;
			text-align: center;
			padding: 6px;
			border-radius: 5px;
			border: 1px solid #424242;
			transition: background-color 0.3s, color 0.3s;
			font-size: 0.9em;
		}
		.run-number:hover {
			background-color: #424242;
			color: #ffffff;
		}
		.header-container .subheader-container h3:empty,
		.header-container .navigation-container h3:empty,
		.header-container .navigation-container .button-group:empty {
			display: none;
			margin: 0;
			padding: 0;
			height: 0;
		}
		.subheader-container {
			display: flex;
			flex-direction: column;
			align-items: flex-start;
			gap: 5px;
			margin-top: 0;
		}        
		.navigation-container {
			display: flex;
			align-items: center;
			gap: 5px;
			margin: 5px 0;
			width: 100%; /* Ensure it stretches */
			justify-content: flex-start; /* Aligns everything to the left */
		}
		.button-group {
			display: flex;
			flex-direction: row;
			gap: 5px;
			align-items: center;
			justify-content: flex-start; /* Ensures buttons stay aligned left */
			margin-left: 0 !important; /* Forces alignment with table */
		}
		#currentRun {
			font-size: 1.7em;
			margin-bottom: 10px;
		}
		#trainDetails {
			margin-top: 5px;
			background-color: #1e1e1e;
			padding: 10px;
			border-radius: 5px;
			border: 1px solid #424242;
			box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
			max-width: 800px;
			min-height: 25px;
			margin-left: auto;
			margin-right: auto;
		}
		#aboutSection {
			margin-top: 20px;
			max-width: 800px;
			margin-left: auto;
			margin-right: auto;
		}
		#aboutText {
			display: none;
			margin-top: 10px;
			background-color: #1e1e1e;
			padding: 10px;
			border-radius: 5px;
			border: 1px solid #424242;
		}
		a {
			color: #1e88e5;
			text-decoration: none;
		}
		a:hover {
			text-decoration: underline;
		}
		.mint-green {
			color: #98ff98;
		}
		
		/* New table styles for consistency */
		table {
			width: 100%;
			border-collapse: collapse;
			margin-top: 5px;
			table-layout: fixed;
		}
		th, td {
			border: 1px solid #424242;
			padding: 5px;
			text-align: center;
			font-size: 0.9em;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		th {
			background-color: #1e88e5;
			color: white;
		}
		tr:nth-child(even) {
			background-color: #2c2c2c;
		}
		tr.clickable {
			cursor: pointer;
		}
		tr.clickable:hover {
			background-color: #424242;
		}
		
		/* Trip List Table column widths */
		#detailsOutput table.trip-list-table tr th:nth-child(1),
		#detailsOutput table.trip-list-table tr td:nth-child(1) {
			width: 10%; /* Trip */
		}
		#detailsOutput table.trip-list-table tr th:nth-child(2),
		#detailsOutput table.trip-list-table tr td:nth-child(2),
		#detailsOutput table.trip-list-table tr th:nth-child(4),
		#detailsOutput table.trip-list-table tr td:nth-child(4) {
			width: 30%; /* From and To */
		}
		#detailsOutput table.trip-list-table tr th:nth-child(3),
		#detailsOutput table.trip-list-table tr td:nth-child(3),
		#detailsOutput table.trip-list-table tr th:nth-child(5),
		#detailsOutput table.trip-list-table tr td:nth-child(5) {
			width: 15%; /* Departing and Arriving */
		}

		/* Stops Table column widths (for all timings and individual trip) */
		#detailsOutput table.stops-table tr th:nth-child(1),
		#detailsOutput table.stops-table tr td:nth-child(1) {
			width: 55%; /* Location */
		}
		#detailsOutput table.stops-table tr th:nth-child(2),
		#detailsOutput table.stops-table tr td:nth-child(2) {
			width: 15%; /* Pl */
		}
		#detailsOutput table.stops-table tr th:nth-child(3),
		#detailsOutput table.stops-table tr td:nth-child(3),
		#detailsOutput table.stops-table tr th:nth-child(4),
		#detailsOutput table.stops-table tr td:nth-child(4) {
			width: 15%; /* Arriving, Departing */
		}

		/* Media query for mobile devices */
		@media screen and (max-width: 768px) {
			table {
				table-layout: auto;
				transform: scale(0.95);
				transform-origin: top left;
				width: 105%;
				margin-right: -5%;
				font-size: 0.95em;
				margin-bottom: 0;
			}
			
			th, td {
				overflow: visible;
				text-overflow: clip;
				width: auto !important;
				padding: 3px;
				vertical-align: middle;
			}
			
			tr {
				height: 44px !important;
			}
			
			#detailsOutput table.trip-list-table tr td:nth-child(1),
			#detailsOutput table.trip-list-table tr td:nth-child(3),
			#detailsOutput table.trip-list-table tr td:nth-child(5) {
				white-space: nowrap;
				min-width: 50px;
			}
			
			#detailsOutput table.stops-table tr td:nth-child(2),
			#detailsOutput table.stops-table tr td:nth-child(3),
			#detailsOutput table.stops-table tr td:nth-child(4) {
				white-space: nowrap;
				min-width: 50px;
			}
			
			#detailsOutput table tr td:nth-child(1) {
				white-space: normal;
				word-break: normal;
				overflow-wrap: break-word;
			}
			
			#detailsOutput table.trip-list-table tr td:nth-child(2),
			#detailsOutput table.trip-list-table tr td:nth-child(4) {
				white-space: normal;
				word-break: normal;
				overflow-wrap: break-word;
			}
			
			#trainDetails {
				padding: 5px;
				overflow: hidden;
			}
			
			#detailsOutput {
				display: inline-block;
				width: 100%;
			}
			
			#detailsOutput:after {
				content: "";
				display: table;
				clear: both;
			}
		}
	</style>
</head>
<body>
    <h1>DLR Timetable Explorer Tool</h1>
    <div style="margin-bottom: 10px;">
        <label for="daySelector">Select Timetable:</label>
        <select id="daySelector" onchange="processCSVAndUpdateURL()">
        </select>
    </div>
	<div id="warningSection">
		<h2>Warning</h2>
		<div id="warningContent"></div>
		<a href="#" id="proceedLink" onclick="showTrainRuns(); return false;" style="display: none;">Proceed with caution.</a>
	</div>
    <div id="trainRunList">
        <h2>Train Run Numbers</h2>
        <div class="grid-container" id="runNumberList" style="margin-top: 10px; margin-bottom: 10px;"></div>
    </div>
    <div id="trainDetails">
        <div class="header-container">
            <div class="subheader-container">
                <h3 id="currentRun"></h3>
            </div>
            <div class="navigation-container">
                <h3 id="tripDetailsHeader"></h3>
                <div class="button-group" id="navigationButtons"></div>
            </div>
        </div>
        <div style="margin-bottom: 5px;" id="detailsOutput">Select a run to view info, or switch to <a href="/search" style="color: #1e88e5; text-decoration: none;">search by location</a> (New!)</div>
    </div>

	<style>
	@keyframes gradientCycle {
		0% { background-position: 150% 0%, 0% 50%; }
		33% { background-position: 100% 100%, 50% 50%; }
		66% { background-position: 50% 50%, 100% 0%; }
		100% { background-position: 0% 0%, 150% 50%; }
	}
	</style>

	<div id="aboutSection">
		<a href="#" id="aboutLink" onclick="toggleAboutSection(); return false;">About this tool</a>
		<div id="aboutText">
			Created by <span style="background: linear-gradient(to right, 
							hsl(300, 80%, 70%), 
							hsl(270, 80%, 61%), 
							hsl(235, 85%, 55%), 
							hsl(300, 80%, 70%)); 
						  background-size: 300% 300%; 
						  -webkit-background-clip: text; 
						  color: transparent; 
						  font-weight: bold; 
						  animation: gradientCycle 5s linear infinite;">
						  Omari A.</span> üè≥Ô∏è‚Äçüåà using 
			<a href="https://tfl.gov.uk/corporate/transparency/freedom-of-information/foi-request-detail?referenceId=FOI-2196-2425" target="_blank">
				publicly available data</a>.<br><br>
			This is a simple tool that pulls data from the raw Working Timetable (WTT) files. However, there may be unknown issues, and 
			<b>no liability is taken for any incorrect information shown.</b><br><br>
			This tool uses the base WTTs (currently <span id="timetableFiles"></span>) and will be incorrect during periods of modified working 
			(e.g., weekend engineering works).<br><br>
			<b>Updates:</b><br>
			06/03/25 Added a brand new 'search by location' page! You can now look up train services based on locations, platform number, and departure time.<br><br>
			01/03/25 The tool now automatically detects and shows when runs transition throughout the day (i.e Run 302 becoming Run 456.)<br><br>
			19/02/25 The tool will now default to the correct timetable for the current day of the week, and has had live service status added to warn when info is likely incorrect.
		</div>
	</div>


    <script>
		const STATUS_MAPPINGS = {
			0: { name: 'Special Service', color: '#f9ff00', suffix: 'that the DLR is operating a Special Service.' },
			1: { name: 'Closed', color: '#F44336', suffix: 'that the DLR is Closed.' },
			2: { name: 'Suspended', color: '#ff0000', suffix: 'that the DLR is Suspended.' },
			3: { name: 'Part Suspended', color: '#ff0000', suffix: 'that the DLR is Part Suspended.' },
			4: { name: 'Planned Closure', color: '#f9ff00', suffix: 'a Planned Closure on the DLR.' },
			5: { name: 'Part Closure', color: '#f9ff00', suffix: 'a Part Closure on the DLR.' },
			6: { name: 'Severe Delays', color: '#ff0000', suffix: 'Severe Delays on the DLR.' },
			7: { name: 'Reduced Service', color: '#f9ff00', suffix: 'a Reduced Service on the DLR.' },
			9: { name: 'Minor Delays', color: '#ff9b00', suffix: 'Minor Delays on the DLR.' },
			10: { name: 'Good Service', color: '#4CAF50', suffix: 'that the DLR is operating with a Good Service.' },
			11: { name: 'Part Closed', color: '#f9ff00', suffix: 'that the DLR is Part Closed.' },
			16: { name: 'Not Running', color: '#ff0000', suffix: 'that the DLR is Not Running.' },
			20: { name: 'No Service', color: '#ff0000', suffix: 'No Service on the DLR.' }
		};

		const WARNING_TRIGGERS = [0, 2, 3, 4, 5, 6, 7, 8, 9, 11];

		async function checkTfLStatus() {
			try {
				// Fetch service overrides
				const overrideResponse = await fetch('https://raw.githubusercontent.com/dlrttbl/dlrttbl.github.io/refs/heads/main/serviceoverrides.txt', { cache: 'no-store' });
				const overrideText = await overrideResponse.text();
				const overrideLines = overrideText.split('\n').filter(line => line.trim() !== '');
				
				// Get current operating date
				const operatingDate = getOperatingDate();
				
				// Process service overrides
				let overrideStatus = null;
				let currentEntry = {};
				const serviceOverrides = [];
				
				for (const line of overrideLines) {
					const trimmedLine = line.trim();
					if (trimmedLine.startsWith('Mapping:')) {
						if (Object.keys(currentEntry).length > 0) {
							serviceOverrides.push({...currentEntry});
						}
						currentEntry = {
							mapping: parseInt(trimmedLine.substring(8).trim(), 10)
						};
					} else if (trimmedLine.startsWith('Applies:')) {
						currentEntry.applies = trimmedLine.substring(8).trim().replace(/['"]/g, '');
					}
				}
				
				// Add the last entry
				if (Object.keys(currentEntry).length > 0) {
					serviceOverrides.push(currentEntry);
				}
				
				// Find applicable override
				const applicableOverride = serviceOverrides.find(entry => {
					const ranges = entry.applies.split(',').map(r => r.trim());
					return ranges.some(range => {
						// Handle single date or date range
						if (range.includes('/')) {
							const [start, end] = range.split('/').map(d => {
								const newDate = new Date(d.trim());
								newDate.setHours(0, 0, 0, 0);
								return newDate;
							});
							const compareDate = new Date(operatingDate);
							compareDate.setHours(0, 0, 0, 0);
							return compareDate >= start && compareDate <= end;
						} else {
							// Single date
							const date = new Date(range);
							date.setHours(0, 0, 0, 0);
							const compareDate = new Date(operatingDate);
							compareDate.setHours(0, 0, 0, 0);
							return +compareDate === +date;
						}
					});
				});
				
				// Fetch TfL status
				const response = await fetch('https://api.tfl.gov.uk/Line/dlr/Status');
				const data = await response.json();
				const statuses = data[0].lineStatuses;
				
				// Use the override status if one is found, otherwise use the TfL API status
				const statusToUse = applicableOverride !== undefined 
					? [{ statusSeverity: applicableOverride.mapping }] 
					: statuses;
				
				// Filter only the statuses that are in both our warning triggers AND our mappings
				const warningStatuses = statusToUse.filter(status => 
					WARNING_TRIGGERS.includes(status.statusSeverity) && 
					STATUS_MAPPINGS[status.statusSeverity]
				);
				
				if (warningStatuses.length > 0) {
					// Sort by severity (lower number = more severe)
					const mostSevereStatus = warningStatuses.sort((a, b) => 
						a.statusSeverity - b.statusSeverity
					)[0];
					
					const statusInfo = STATUS_MAPPINGS[mostSevereStatus.statusSeverity];
					const warningContent = document.getElementById('warningContent');
					const proceedLink = document.getElementById('proceedLink');
					
					warningContent.innerHTML = `TfL is currently reporting ${statusInfo.suffix.replace(statusInfo.name, `<span style="color: ${statusInfo.color}">${statusInfo.name}</span>`)} <br>As a result the information on this page is likely to be incorrect. `;
					
					document.getElementById('warningSection').style.display = 'block';
					
					// Handle direct URLs
					const hash = window.location.hash;
					if (hash.includes('run=')) {
						proceedLink.style.display = 'none';
						document.getElementById('trainRunList').style.display = 'block';
						document.getElementById('trainDetails').style.display = 'block';
					} else {
						proceedLink.style.display = 'inline';
						warningContent.appendChild(proceedLink);
						document.getElementById('trainRunList').style.display = 'none';
						document.getElementById('trainDetails').style.display = 'none';
					}
				}
			} catch (error) {
				console.error('Error checking TfL status:', error);
			}
		}

		function showTrainRuns() {
			document.getElementById('trainRunList').style.display = 'block';
			document.getElementById('trainDetails').style.display = 'block';
			document.getElementById('proceedLink').style.display = 'none';
		}
	
        let currentRunData = null;
        let showingAllTimings = false;
        let selectedTrip = null;
        let currentTrips = [];
        let timetablePaths = {};
        let archivedTimetablePaths = {};
        let currentPath = null;
		let isLoadingFromURL = false;
		let runTransitions = {};

		async function fetchTimetablePaths() {
			try {
				// Fetch main timetables
				const response = await fetch('https://raw.githubusercontent.com/dlrttbl/dlrttbl.github.io/refs/heads/main/paths.txt', { cache: 'no-store' });
				const text = await response.text();
				const lines = text.split('\n').filter(line => line.trim() !== '');
				
				let currentEntry = {};
				const timetableEntries = [];
				
				// Parse the new format
				for (const line of lines) {
					const trimmedLine = line.trim();
					if (trimmedLine.startsWith('Name:')) {
						if (Object.keys(currentEntry).length > 0) {
							timetableEntries.push({...currentEntry});
						}
						currentEntry = {
							name: trimmedLine.substring(5).trim()
						};
					} else if (trimmedLine.startsWith('Applies:')) {
						currentEntry.applies = trimmedLine.substring(8).trim();
					} else if (trimmedLine.startsWith('URL:')) {
						currentEntry.url = trimmedLine.substring(4).trim();
						const fileName = currentEntry.url.substring(currentEntry.url.lastIndexOf('/') + 1, currentEntry.url.lastIndexOf('.'));
						currentEntry.fileName = fileName.toLowerCase();
					}
				}
				
				// Add the last entry
				if (Object.keys(currentEntry).length > 0) {
					timetableEntries.push(currentEntry);
				}

				// Fetch archived timetables
				try {
					const archivedResponse = await fetch('https://raw.githubusercontent.com/dlrttbl/dlrttbl.github.io/refs/heads/main/archivedpaths.txt', { cache: 'no-store' });
					const archivedText = await archivedResponse.text();
					const archivedLines = archivedText.split('\n').filter(line => line.trim() !== '');
					
					let currentArchivedEntry = {};
					// Process archived timetables
					for (const line of archivedLines) {
						const trimmedLine = line.trim();
						if (trimmedLine.startsWith('Name:')) {
							if (Object.keys(currentArchivedEntry).length > 0) {
								const fileName = currentArchivedEntry.url.substring(currentArchivedEntry.url.lastIndexOf('/') + 1, currentArchivedEntry.url.lastIndexOf('.'));
								archivedTimetablePaths[fileName.toLowerCase()] = {
									url: currentArchivedEntry.url,
									name: currentArchivedEntry.name
								};
							}
							currentArchivedEntry = {
								name: trimmedLine.substring(5).trim()
							};
						} else if (trimmedLine.startsWith('URL:')) {
							currentArchivedEntry.url = trimmedLine.substring(4).trim();
						}
					}
					// Add the last archived entry
					if (Object.keys(currentArchivedEntry).length > 0) {
						const fileName = currentArchivedEntry.url.substring(currentArchivedEntry.url.lastIndexOf('/') + 1, currentArchivedEntry.url.lastIndexOf('.'));
						archivedTimetablePaths[fileName.toLowerCase()] = {
							url: currentArchivedEntry.url,
							name: currentArchivedEntry.name
						};
					}
				} catch (error) {
					console.error('Error fetching archived timetable paths:', error);
				}

				// Clear and populate the day selector
				const select = document.getElementById('daySelector');
				select.innerHTML = '';
				
				// Sort timetables based on current date and time
				const sortedEntries = sortTimetablesByApplicability(timetableEntries);
				
				// Process entries
				sortedEntries.forEach(entry => {
					timetablePaths[entry.fileName] = entry.url;
					
					const option = document.createElement('option');
					option.value = entry.fileName;
					option.textContent = entry.name;
					select.appendChild(option);
				});

				// Update the about section
				const fileNames = sortedEntries.map(entry => 
					`'<span class="mint-green">${entry.fileName}</span>'`
				);
				const fileNamesText = fileNames.length > 1
					? fileNames.slice(0, -1).join(', ') + ', and ' + fileNames.slice(-1)
					: fileNames[0];
				document.getElementById('timetableFiles').innerHTML = fileNamesText;
				
				return sortedEntries[0]?.fileName; // Return the most applicable timetable
			} catch (error) {
				console.error('Error fetching timetable paths:', error);
				return null;
			}
		}

		function getOperatingDate() {
			const now = new Date();
			// If it's before 3 AM, use the previous day's date
			if (now.getHours() < 3) {
				now.setDate(now.getDate() - 1);
			}
			return now;
		}

		function parseDateRange(dateStr) {
			// Remove quotes first
			dateStr = dateStr.replace(/['"]/g, '');
			
			// Handle date ranges with '/'
			if (dateStr.includes('/')) {
				const [start, end] = dateStr.split('/').map(d => {
					const newDate = new Date(d.trim());
					newDate.setHours(0, 0, 0, 0);
					return newDate;
				});
				return { start, end };
			}
			
			// Handle single date
			const newDate = new Date(dateStr);
			newDate.setHours(0, 0, 0, 0);
			return { 
				start: newDate, 
				end: newDate 
			};
		}

		function getDayName(date) {
			return date.toLocaleDateString('en-US', { weekday: 'long' });
		}

		function isDateInRange(date, rangeStr) {
			// Remove quotes and split by comma if multiple values
			const ranges = rangeStr.split(',').map(r => r.trim().replace(/['"]/g, ''));
			
			// Check each range
			return ranges.some(range => {
				// If it's a day name
				if (['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].includes(range)) {
					return getDayName(date) === range;
				}
				
				// If it's a date or date range
				const dateRange = parseDateRange(range);
				const compareDate = new Date(date);
				compareDate.setHours(0, 0, 0, 0);
				return compareDate >= dateRange.start && compareDate <= dateRange.end;
			});
		}
		
		function sortTimetablesByApplicability(entries) {
			const operatingDate = getOperatingDate();
			const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
			
			return entries.sort((a, b) => {
				const aApplies = a.applies.split(',').map(s => s.trim().replace(/['"]/g, ''));
				const bApplies = b.applies.split(',').map(s => s.trim().replace(/['"]/g, ''));
				
				// Check if either timetable has a specific date (anything that's not a day name)
				const aHasSpecificDate = aApplies.some(range => !dayNames.includes(range));
				const bHasSpecificDate = bApplies.some(range => !dayNames.includes(range));
				
				// Check if either timetable applies to the current date/day
				const aAppliesNow = aApplies.some(range => isDateInRange(operatingDate, range));
				const bAppliesNow = bApplies.some(range => isDateInRange(operatingDate, range));
				
				// If both apply now, specific dates take precedence
				if (aAppliesNow && bAppliesNow) {
					if (aHasSpecificDate && !bHasSpecificDate) return -1;
					if (!aHasSpecificDate && bHasSpecificDate) return 1;
				}
				
				// Then timetables that apply today
				if (aAppliesNow && !bAppliesNow) return -1;
				if (!aAppliesNow && bAppliesNow) return 1;
				
				// If neither applies, sort by name
				return a.name.localeCompare(b.name);
			});
		}

		window.onload = () => {
			// Check TfL status first
			checkTfLStatus();
			
			fetchTimetablePaths().then((defaultTimetable) => {
				if (!window.location.hash && defaultTimetable) {
					const newURL = `${window.location.pathname}#timetable=${defaultTimetable}`;
					window.history.replaceState(null, '', newURL);
					processCSVFromURL();
				} else {
					processCSVFromURL();
				}
			});

			// Listen for hashchange event
			window.addEventListener('hashchange', processCSVFromURL);
		};

        function toggleAboutSection() {
            const aboutText = document.getElementById('aboutText');
            if (aboutText.style.display === 'none' || aboutText.style.display === '') {
                aboutText.style.display = 'block';
            } else {
                aboutText.style.display = 'none';
            }
        }

		function showArchivedTimetables() {
			const select = document.getElementById('daySelector');
			// Clear existing options
			select.innerHTML = '';
			
			// Get original names from paths.txt by fetching again
			const fetchNames = async () => {
				const response = await fetch('https://raw.githubusercontent.com/dlrttbl/dlrttbl.github.io/refs/heads/main/paths.txt', { cache: 'no-store' });
				const text = await response.text();
				const lines = text.split('\n').filter(line => line.trim() !== '');
				
				let currentEntry = {};
				const timetableEntries = [];
				
				// Parse the active timetables
				for (const line of lines) {
					const trimmedLine = line.trim();
					if (trimmedLine.startsWith('Name:')) {
						if (Object.keys(currentEntry).length > 0) {
							timetableEntries.push({...currentEntry});
						}
						currentEntry = {
							name: trimmedLine.substring(5).trim()
						};
					} else if (trimmedLine.startsWith('URL:')) {
						currentEntry.url = trimmedLine.substring(4).trim();
						const fileName = currentEntry.url.substring(currentEntry.url.lastIndexOf('/') + 1, currentEntry.url.lastIndexOf('.'));
						currentEntry.fileName = fileName.toLowerCase();
					}
				}
				
				// Add the last entry
				if (Object.keys(currentEntry).length > 0) {
					timetableEntries.push(currentEntry);
				}

				// Add active timetables
				timetableEntries.forEach(entry => {
					const option = document.createElement('option');
					option.value = entry.fileName;
					option.textContent = entry.name;
					select.appendChild(option);
				});

				// Add archived timetables
				Object.entries(archivedTimetablePaths).forEach(([fileName, data]) => {
					const option = document.createElement('option');
					option.value = fileName;
					option.textContent = data.name;
					select.appendChild(option);
				});
			};

			fetchNames();
		}

		async function detectRunTransitions() {
			// Fetch the raw CSV data again
			let csvText = '';
			try {
				const response = await fetch(currentPath);
				csvText = await response.text();
			} catch (error) {
				console.error('Error loading CSV data for transition detection:', error);
				return {};
			}

			const lines = csvText.split('\n').filter(line => line.trim() !== '');
			const transitions = {};
			
			// Adjacency map of DLR stations
			const adjacencyMap = {
				"ABR": ["SHS", "WEH"],
				"ALS": ["LAP", "POP"],
				"BAN": ["SHA", "BANH"],
				"BANH": ["BAN"],
				"BEC": ["GAR"],
				"BEP": ["CYP", "ROA"],
				"BLA": ["EAI", "POP"],
				"BOC": ["DER", "PML"],
				"CAT": ["EAI", "ROV", "STL", "WST"],
				"CAW": ["HEQ", "WES", "WIQ"],
				"CRO": ["MUD", "SOQ"],
				"CUH": ["PRR", "ROV"],
				"CUS": ["GRE", "ISG"],
				"CYP": ["BEP", "GAR"],
				"DEB": ["ELR", "GRE"],
				"DER": ["BOC", "LAP"],
				"EAI": ["BLA", "CAT"],
				"ELR": ["DEB", "LEW"],
				"GAR": ["BEC", "CYP"],
				"GRE": ["CUS", "DEB"],
				"HEQ": ["CAW", "SOQ"],
				"ISG": ["CUS", "MUD"],
				"KGV": ["LCA", "WOA"],
				"LAP": ["ALS", "DER"],
				"LCA": ["KGV", "PDK"],
				"LEW": ["ELR"],
				"LIM": ["SHA", "WES"],
				"MUD": ["CRO", "ISG"],
				"PDK": ["LCA", "WST"],
				"PML": ["BOC", "STR"],
				"POP": ["ALS", "BLA", "WES", "WIQ"],
				"PRR": ["CUH", "ROA"],
				"ROA": ["BEP", "PRR"],
				"ROV": ["CAT", "CUH"],
				"SHA": ["BAN", "LIM", "TOG"],
				"SHS": ["ABR", "STR"],
				"SOQ": ["CRO", "HEQ"],
				"STI": ["STR"],
				"STL": ["CAT", "WEH"],
				"STR": ["PML", "SHS", "STI"],
				"TOG": ["SHA"],
				"WEH": ["ABR", "STL"],
				"WES": ["CAW", "LIM", "POP", "WIQ"],
				"WIQ": ["CAW", "POP", "WES"],
				"WOA": ["KGV"],
				"WST": ["CAT", "PDK"]
			};
			
			// Helper function to extract station code
			function getStationCode(locationCode) {
				if (locationCode === "BANH") return "BANH";
				if (locationCode === "STR4B") return "STR";
				return locationCode.substring(0, 3);
			}
			
			// Function to check if stations are adjacent
			function areStationsAdjacent(station1, station2) {
				const code1 = getStationCode(station1);
				const code2 = getStationCode(station2);
				
				// Same station (different platforms)
				if (code1 === code2) return true;
				
				// Check adjacency map
				if (adjacencyMap[code1] && adjacencyMap[code1].includes(code2)) return true;
				if (adjacencyMap[code2] && adjacencyMap[code2].includes(code1)) return true;
				
				return false;
			}
			
			// Function to parse time
			function parseTime(timeStr) {
				const [hours, minutes, seconds] = timeStr.split(':').map(Number);
				return hours * 3600 + minutes * 60 + seconds;
			}
			
			// First, create a map of run numbers to their line indices
			const runLineIndices = {};
			lines.forEach((line, index) => {
				const parts = line.split(',');
				if (parts.length >= 7) {
					const runNumber = parts[1].trim();
					if (!runLineIndices[runNumber]) {
						runLineIndices[runNumber] = [];
					}
					runLineIndices[runNumber].push(index);
				}
			});
			
			// Get a sorted list of all run numbers
			const allRuns = Object.keys(runLineIndices);
			
			// For each run, find its last stop
			for (const fromRun of allRuns) {
				const fromRunIndices = runLineIndices[fromRun];
				if (fromRunIndices.length === 0) continue;
				
				// Get the last line index for this run
				const lastLineIndex = Math.max(...fromRunIndices);
				const lastLine = lines[lastLineIndex];
				const lastLineParts = lastLine.split(',');
				
				// Extract details from the last line
				const lastLocationCode = lastLineParts[4].trim();
				const lastDepartureTime = lastLineParts[6].trim();
				const lastDepartureSeconds = parseTime(lastDepartureTime);
				
				// Skip if it's a junction
				if (lastLocationCode.startsWith('J')) continue;
				
				// Check the next few lines to see if another run starts
				const locationMapping = {
					'STR4B': 'Stratford',
					'BEC2': 'Beckton',
					'LEW6': 'Lewisham'
				};
				
				for (let i = lastLineIndex + 1; i <= lastLineIndex + 3 && i < lines.length; i++) {
					const nextLine = lines[i];
					const nextLineParts = nextLine.split(',');
					
					if (nextLineParts.length < 7) continue;
					
					const nextRun = nextLineParts[1].trim();
					if (nextRun === fromRun) continue; // Skip same run
					
					// Only consider this if it's the first occurrence of the next run
					if (Math.min(...runLineIndices[nextRun]) !== i) continue;
					
					const nextLocationCode = nextLineParts[4].trim();
					const nextArrivalTime = nextLineParts[5].trim();
					const nextArrivalSeconds = parseTime(nextArrivalTime);
					
					// Skip if it's a junction
					if (nextLocationCode.startsWith('J')) continue;
					
					// Calculate time difference
					const timeDiffMinutes = (nextArrivalSeconds - lastDepartureSeconds) / 60;
					
					// Apply the three rules:
					// 1. Stations must be adjacent
					// 2. Time gap must be 0.5-5 minutes
					// 3. The runs should be examined in the order they appear in the data
					if (areStationsAdjacent(lastLocationCode, nextLocationCode) && 
						timeDiffMinutes >= 0.5 && 
						timeDiffMinutes <= 5) {
						
						// Get the location name
						let locationName = locationMapping[nextLocationCode] || 'Unknown';
						
						transitions[fromRun] = { 
							nextRun, 
							location: locationName 
						};
						
						// Just before returning, store the last location for UI purposes
						transitions[fromRun].fromLocation = lastLocationCode;						
						
						break; // Found the next run, no need to check others
					}
				}
			}
			
			return transitions;
		}

        function detectTrips(stops) {
            const trips = [];
            let currentTrip = [];
            let tripNumber = 1;

            for (let i = 0; i < stops.length; i++) {
                currentTrip.push(stops[i]);

                if (i < stops.length - 2) {
                    const loc1 = stops[i].location;
                    const loc2 = stops[i + 1].location;
                    const loc3 = stops[i + 2].location;

                    if (loc1 === loc3 && loc1 !== loc2) {
                        trips.push({
                            tripNumber,
                            from: currentTrip[0].location,
                            departureTime: currentTrip[0].departureTime,
                            to: loc2,
                            arrivalTime: stops[i + 1].arrivalTime,
                            stops: [...currentTrip, stops[i + 1]]
                        });
                        
                        currentTrip = [stops[i + 1]];
                        tripNumber++;
                        i++;
                    }
                }
            }

            if (currentTrip.length > 0) {
                trips.push({
                    tripNumber,
                    from: currentTrip[0].location,
                    departureTime: currentTrip[0].departureTime,
                    to: currentTrip[currentTrip.length - 1].location,
                    arrivalTime: currentTrip[currentTrip.length - 1].arrivalTime,
                    stops: [...currentTrip]
                });
            }

            return trips;
        }
		
		function getFormedFromRun(runNumber) {
			for (const [fromRun, transition] of Object.entries(runTransitions)) {
				if (transition.nextRun === runNumber) {
					// Use the last location of the previous run for "Formed from"
					const fromLocation = transition.fromLocation || transition.location;
					return { fromRun, location: fromLocation };
				}
			}
			return null;
		}

        function updateNavigationButtons() {
            const navigationButtons = document.getElementById('navigationButtons');
            const tripDetailsHeader = document.getElementById('tripDetailsHeader');
            navigationButtons.innerHTML = '';

            // Only show navigation buttons if we have current run data
            if (!currentRunData) {
                tripDetailsHeader.textContent = '';
                return;
            }

            if (selectedTrip) {
                tripDetailsHeader.textContent = `Trip ${selectedTrip.tripNumber} Details`;
                const tripNav = document.createElement('div');
                tripNav.className = 'button-group';
                
                const prevButton = document.createElement('button');
                prevButton.textContent = 'Previous Trip';
                prevButton.disabled = selectedTrip.tripNumber === 1;
                prevButton.onclick = () => {
                    const prevTrip = currentTrips.find(t => t.tripNumber === selectedTrip.tripNumber - 1);
                    if (prevTrip) displayTrip(prevTrip);
                };
                
                const nextButton = document.createElement('button');
                nextButton.textContent = 'Next Trip';
                nextButton.disabled = selectedTrip.tripNumber === currentTrips.length;
                nextButton.onclick = () => {
                    const nextTrip = currentTrips.find(t => t.tripNumber === selectedTrip.tripNumber + 1);
                    if (nextTrip) displayTrip(nextTrip);
                };
                
                const backButton = document.createElement('button');
                backButton.textContent = 'Trip List';
                backButton.onclick = () => {
                    selectedTrip = null;
                    displayCurrentData();
                    updateURLHash();
                };

                tripNav.appendChild(prevButton);
                tripNav.appendChild(nextButton);
                tripNav.appendChild(backButton);
                navigationButtons.appendChild(tripNav);
            } else if (currentRunData) {  // Only show toggle button if we have run data
                tripDetailsHeader.textContent = '';
                const toggleButton = document.createElement('button');
                toggleButton.id = 'toggleView';
                toggleButton.textContent = showingAllTimings ? 'Show Trips' : 'Show All Timings';
                toggleButton.className = showingAllTimings ? 'red-background' : '';
                toggleButton.onclick = toggleView;
                toggleButton.style.marginBottom = '5px';
                navigationButtons.appendChild(toggleButton);
            }
        }

		async function processCSVFromURL() {
			const hash = window.location.hash.substring(1);
			
			// If no hash, redirect to first timetable and return early
			if (!hash) {
				const firstTimetable = Object.keys(timetablePaths)[0];
				if (firstTimetable) {
					window.location.hash = `#timetable=${firstTimetable}`;
				}
				return;
			}
			
			const urlParams = new URLSearchParams(hash);
			
			// Get all parameters in the hash
			const params = Array.from(urlParams.keys());
			
			// Clear run data if we're at the base timetable URL
			if (params.length === 1 && params[0] === 'timetable') {
				clearRunSelection();
			}
			
			// Special handling for archived view
			if (params.length === 1 && params[0] === 'archived') {
				showArchivedTimetables();
				clearRunSelection();
				return;
			}
				
			// Define valid parameter orders
			const validOrders = [
				['timetable'],
				['timetable', 'run'],
				['timetable', 'run', 'showall'],
				['timetable', 'run', 'trip'],
				['archived'] 
			];
				
			// Check if the parameter order matches any valid order
			const isValidOrder = validOrders.some(order => 
				params.length === order.length && 
				params.every((param, index) => param === order[index])
			);
				
			if (!isValidOrder) {
				alert('The URL you entered is invalid.');
				const firstTimetable = Object.keys(timetablePaths)[0];
				if (firstTimetable) {
					window.location.hash = `#timetable=${firstTimetable}`;
				}
				clearRunSelection();
				return;
			}

			const timetable = urlParams.get('timetable');
			const run = urlParams.get('run');
			const trip = urlParams.get('trip');
			const showall = urlParams.has('showall');

			// Check if timetable exists in either active or archived paths
			currentPath = timetablePaths[timetable] || archivedTimetablePaths[timetable]?.url;
			if (!timetable || !currentPath) {
				alert('No data matches the URL you entered.');
				const firstTimetable = Object.keys(timetablePaths)[0];
				if (firstTimetable) {
					window.location.hash = `#timetable=${firstTimetable}`;
				}
				clearRunSelection();
				return;
			}

			// Set the appropriate timetable in the dropdown selector
			isLoadingFromURL = true;
			if (timetablePaths[timetable]) {
				document.getElementById('daySelector').value = timetable;
			} else {
				const select = document.getElementById('daySelector');
				// Remove any previous archived options
				Array.from(select.options).forEach(option => {
					if (!timetablePaths[option.value]) {
						select.removeChild(option);
					}
				});
				// Add the new archived option
				const tempOption = document.createElement('option');
				tempOption.value = timetable;
				tempOption.textContent = archivedTimetablePaths[timetable].name;
				select.appendChild(tempOption);
				select.value = timetable;
			}
			isLoadingFromURL = false;

			await processCSV();

			// Check if run number exists in the data
			if (run) {
				if (!currentRunData || !currentRunData[run]) {
					alert('No data matches the URL you entered.');
					window.location.hash = `#timetable=${timetable}`;
					clearRunSelection();
					return;
				}
				displayDetails(run, currentRunData[run]);

				// Check if trip number is valid
				if (trip) {
					const tripNumber = parseInt(trip, 10);
					const selectedTripData = currentTrips.find(t => t.tripNumber === tripNumber);
					if (!selectedTripData) {
						alert('No data matches the URL you entered.');
						window.location.hash = `#timetable=${timetable}&run=${run}`;
						selectedTrip = null;
						displayCurrentData();
						return;
					}
					displayTrip(selectedTripData);
				}
			} else {
				clearRunSelection(); // Clear run data if no run parameter is present
			}

			if (showall) {
				showingAllTimings = true;
				displayCurrentData();
			}
		}

		async function processCSVAndUpdateURL() {
			if (isLoadingFromURL) return; // Don't process if loading from URL
			
			const day = document.getElementById('daySelector').value;
			clearRunSelection(); // Always clear run selection when changing timetables
			currentPath = timetablePaths[day];
			window.location.hash = `#timetable=${day}`;
			await processCSV();
		}

		const locationMapping = {
			'ABR': 'Abbey Road', 'ALS': 'All Saints', 'BAN': 'Bank', 'BEC': 'Beckton', 
			'BEP': 'Beckton Park', 'BLA': 'Blackwall', 'BOC': 'Bow Church', 'CAW': 'Canary Wharf',
			'CAT': 'Canning Town', 'CRO': 'Crossharbour', 'CUH': 'Custom House', 'CUS': 'Cutty Sark',
			'CYP': 'Cyprus', 'DEB': 'Deptford Bridge', 'DER': 'Devons Road', 'EAI': 'East India',
			'ELR': 'Elverson Road', 'GAR': 'Gallions Reach', 'GRE': 'Greenwich', 'HEQ': 'Heron Quays',
			'ISG': 'Island Gardens', 'KGV': 'King George V', 'LAP': 'Langdon Park', 'LEW': 'Lewisham',
			'LIM': 'Limehouse', 'LCA': 'London City Airport', 'MUD': 'Mudchute', 'PDK': 'Pontoon Dock',
			'POP': 'Poplar', 'PRR': 'Prince Regent', 'PML': 'Pudding Mill Lane', 'ROA': 'Royal Albert',
			'ROV': 'Royal Victoria', 'SHA': 'Shadwell', 'SOQ': 'South Quay', 'STL': 'Star Lane',
			'SHS': 'Stratford High Street', 'STI': 'Stratford International', 'STR': 'Stratford',
			'TOG': 'Tower Gateway', 'WEH': 'West Ham', 'WIQ': 'West India Quay', 'WST': 'West Silvertown',
			'WES': 'Westferry', 'WOA': 'Woolwich Arsenal'
		};

        async function processCSV() {
            let csvText = '';
            try {
                const response = await fetch(currentPath);
                csvText = await response.text();
            } catch (error) {
                console.error('Error loading CSV data:', error);
                return;
            }

            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            const runData = {};

            const junctions = [
                'JRMS', 'JRMX', 'JCAW', 'JWEM', 'JCRO', 'JC2M', 'JC3M',
                'JC4M', 'JROM', 'JWEX', 'JCTM', 'JCTX', 'JWIQ', 'JNQX',
                'JNQM', 'JWSX', 'JWSM', 'ISP2', 'ISP3'
            ];

            lines.forEach((line, index) => {
                const parts = line.split(',');
                if (parts.length >= 7) {
                    const runNumber = parts[1].trim();
                    const locationCode = parts[4].trim();
                    const arrivalTime = parts[5].trim();
                    const departureTime = parts[6].trim();

                    if (!junctions.includes(locationCode)) {
                        if (!runData[runNumber]) {
                            runData[runNumber] = [];
                        }

                        let location = '';
                        let platform = '';

                        if (locationCode === 'BANH') {
                            location = 'Bank Headshunt';
                        } else {
                            const codePrefix = locationCode.slice(0, 3);
                            platform = locationCode.slice(3);

                            if (locationMapping[codePrefix]) {
                                location = locationMapping[codePrefix];
                                if (['LEW', 'BEC', 'STI', 'WOA'].includes(codePrefix) || locationCode === 'STR4B') {
                                    platform = '';
                                }
                            } else {
                                location = locationCode;
                                platform = '';
                            }
                        }

                        runData[runNumber].push({
                            location,
                            platform,
                            arrivalTime,
                            departureTime
                        });
                    }
                }
            });

            currentRunData = runData;

            const runNumberList = document.getElementById('runNumberList');
            runNumberList.innerHTML = '';

            Object.keys(runData).forEach(runNumber => {
                const div = document.createElement('div');
                div.textContent = runNumber;
                div.className = 'run-number';
                div.onclick = () => {
                    displayDetails(runNumber, runData[runNumber]);
                    updateURLHash();
                };
                runNumberList.appendChild(div);
            });
			
			// Detect transitions between runs (same physical train changing run number)
			runTransitions = await detectRunTransitions();

        }

        function toggleView() {
            showingAllTimings = !showingAllTimings;
            selectedTrip = null;
            displayCurrentData();
            updateURLHash();
        }

        function displayTrip(trip) {
            selectedTrip = trip;
            displayCurrentData();
            updateURLHash();
        }

		function displayCurrentData() {
			const detailsOutput = document.getElementById('detailsOutput');
			const runNumber = document.getElementById('currentRun').textContent.split(' ')[1];
			
			if (!currentRunData) {
				detailsOutput.innerHTML = 'Select a run to view info, or switch to <a href="/search" style="color: #1e88e5; text-decoration: none;">search by location</a> (New!)';
				return;
			}

			updateNavigationButtons();

			if (showingAllTimings) {
				displayStopsTable(currentRunData);
			} else if (selectedTrip) {
				// Create a special parameter object to control which transition messages to show
				const tripParams = {
					runNumber: runNumber,
					showFormedFrom: selectedTrip.tripNumber === 1,  // Only on first trip
					showFormsRun: selectedTrip.tripNumber === currentTrips.length  // Only on last trip
				};
				
				detailsOutput.innerHTML = `
					${createStopsTable(selectedTrip.stops, tripParams)}
				`;
			} else {
				currentTrips = detectTrips(currentRunData);
				displayTripsTable(currentTrips, runNumber);
			}
		}

		function filterTable() {
			const locationFilter = document.getElementById('locationFilter').value.toLowerCase();
			const platformFilter = document.getElementById('platformFilter').value.toLowerCase();
			
			const tableRows = document.querySelectorAll('#detailsOutput table.stops-table tbody tr');
			
			tableRows.forEach(row => {
				const location = row.cells[0].textContent.toLowerCase();
				const platform = row.cells[1].textContent.toLowerCase();
				
				const locationMatch = location.includes(locationFilter);
				const platformMatch = platform.includes(platformFilter);
				
				// Show row if both filters match (or if that filter is empty)
				if ((locationMatch || locationFilter === '') && 
					(platformMatch || platformFilter === '')) {
					row.style.display = '';
				} else {
					row.style.display = 'none';
				}
			});
		}
		function clearFilters() {
			document.getElementById('locationFilter').value = '';
			document.getElementById('platformFilter').value = '';
			filterTable(); // Re-run filter to show all rows
		}

        function displayDetails(runNumber, data) {
            currentRunData = data;
            showingAllTimings = false;
            selectedTrip = null;
            document.getElementById('currentRun').textContent = `Run ${runNumber}`;
            displayCurrentData();
        }

		function createStopsTable(stops, params) {
			// Handle different parameter formats
			let runNumber = null;
			let showFormedFrom = true;
			let showFormsRun = true;
			
			if (typeof params === 'string') {
				// Old format: just the run number
				runNumber = params;
			} else if (params && typeof params === 'object') {
				// New format: parameter object
				runNumber = params.runNumber;
				showFormedFrom = params.showFormedFrom !== false;
				showFormsRun = params.showFormsRun !== false;
			}
			
			let tableHTML = '';
			
			// Add "Formed from" message if applicable, BEFORE the table starts
			if (runNumber && showFormedFrom) {
				const formedFrom = getFormedFromRun(runNumber);
				if (formedFrom) {
					const timetable = document.getElementById('daySelector').value;
					const previousRunURL = `#timetable=${timetable}&run=${formedFrom.fromRun}`;
					
					// Get the actual last location of the previous run
					let previousRunLastLocation = '';
					if (currentRunData[formedFrom.fromRun]) {
						const previousRunStops = currentRunData[formedFrom.fromRun];
						const lastStop = previousRunStops[previousRunStops.length - 1];
						previousRunLastLocation = lastStop.location;
					}

					// If still empty, try to convert from the transition detection
					if (!previousRunLastLocation && formedFrom.location) {
						previousRunLastLocation = locationMapping[formedFrom.location.slice(0, 3)] || formedFrom.location;
					}

					// Fallback to something meaningful if location is empty
					if (!previousRunLastLocation) {
						previousRunLastLocation = 'Unknown Location';
					}
					
					tableHTML += `
						<div style="
							display: flex; 
							justify-content: center; 
							align-items: center; 
							cursor: pointer; 
							background-color: #f72f5e; 
							border: 1px solid #424242; 
							padding: 5px; 
							transition: background-color 0.3s; 
							height: 30px;"
							onclick="window.location.hash='${previousRunURL}'"
							onmouseover="this.style.backgroundColor='#d61c4e'"
							onmouseout="this.style.backgroundColor='#f72f5e'">
							<span style="color: #ffffff; font-weight: bold; font-size: 0.9em !important;">
								‚Ü™ Formed from Run ${formedFrom.fromRun} departing ${previousRunLastLocation}
							</span>
						</div>
					`;
				}
			}
			
			// Now start the main table
			tableHTML += `
				<table class="stops-table" style="margin-top: 0;">
					<thead>
						<tr>
							<th>Location</th>
							<th>Pl</th>
							<th>Arriving</th>
							<th>Departing</th>
						</tr>
					</thead>
					<tbody>
			`;

			stops.forEach(entry => {
				tableHTML += `
					<tr>
						<td>${entry.location}</td>
						<td>${entry.platform}</td>
						<td>${entry.arrivalTime}</td>
						<td>${entry.departureTime}</td>
					</tr>
				`;
			});

			// Close the table
			tableHTML += `
					</tbody>
				</table>
			`;

		// Add "Forms Run" message if applicable, AFTER the table as a separate div
			if (runNumber && showFormsRun && runTransitions[runNumber]) {
				const nextRun = runTransitions[runNumber].nextRun;
				const location = runTransitions[runNumber].toLocation || runTransitions[runNumber].location;
				
				const timetable = document.getElementById('daySelector').value;
				const nextRunURL = `#timetable=${timetable}&run=${nextRun}`;
				
				tableHTML += `
					<div style="
						display: flex; 
						justify-content: center; 
						align-items: center; 
						cursor: pointer; 
						background-color: #f72f5e; 
						border: 1px solid #424242; 
						padding: 5px; 
						transition: background-color 0.3s; 
						height: 30px;
						margin-top: 0;"
						onclick="window.location.hash='${nextRunURL}'"
						onmouseover="this.style.backgroundColor='#d61c4e'"
						onmouseout="this.style.backgroundColor='#f72f5e'">
						<span style="color: #ffffff; font-weight: bold; font-size: 0.9em !important;">
							‚Ü™ Forms Run ${nextRun} arriving at ${location}
						</span>
					</div>
				`;
			}

			return tableHTML;
		}

		function displayStopsTable(stops) {
			const runNumber = document.getElementById('currentRun').textContent.split(' ')[1];
			const detailsOutput = document.getElementById('detailsOutput');
			
			// Add filter inputs before the table
			const filterHTML = `
				<div class="filter-container" style="margin-bottom: 10px; display: flex; gap: 5px;">
					<input type="text" id="locationFilter" placeholder="Filter by location" style="flex: 2; padding: 5px; background-color: #2c2c2c; color: white; border: 1px solid #424242; border-radius: 4px;">
					<input type="text" id="platformFilter" placeholder="Filter by platform" style="flex: 1; padding: 5px; background-color: #2c2c2c; color: white; border: 1px solid #424242; border-radius: 4px;">
				</div>
			`;
			
			// Combine filter and table HTML
			detailsOutput.innerHTML = filterHTML + createStopsTable(stops, {
				runNumber: runNumber,
				showFormedFrom: true,
				showFormsRun: true
			});
			
			// Add event listeners for filtering
			document.getElementById('locationFilter').addEventListener('input', filterTable);
			document.getElementById('platformFilter').addEventListener('input', filterTable);
		}

		function displayTripsTable(trips, runNumber) {
			let tableHTML = '';
			
			// Add "Formed from" message if applicable, BEFORE the table starts
			if (runNumber) {
				const formedFrom = getFormedFromRun(runNumber);
				if (formedFrom) {
					const timetable = document.getElementById('daySelector').value;
					const previousRunURL = `#timetable=${timetable}&run=${formedFrom.fromRun}`;
					
					// Get the actual last location of the previous run
					let previousRunLastLocation = '';
					if (currentRunData[formedFrom.fromRun]) {
						const previousRunStops = currentRunData[formedFrom.fromRun];
						const lastStop = previousRunStops[previousRunStops.length - 1];
						previousRunLastLocation = lastStop.location;
					}

					// If still empty, try to convert from the transition detection
					if (!previousRunLastLocation && formedFrom.location) {
						previousRunLastLocation = locationMapping[formedFrom.location.slice(0, 3)] || formedFrom.location;
					}

					// Fallback to something meaningful if location is empty
					if (!previousRunLastLocation) {
						previousRunLastLocation = 'Unknown Location';
					}
					
					tableHTML += `
						<div style="
							display: flex; 
							justify-content: center; 
							align-items: center; 
							cursor: pointer; 
							background-color: #f72f5e; 
							border: 1px solid #424242; 
							padding: 5px; 
							transition: background-color 0.3s; 
							height: 30px;"
							onclick="window.location.hash='${previousRunURL}'"
							onmouseover="this.style.backgroundColor='#d61c4e'"
							onmouseout="this.style.backgroundColor='#f72f5e'">
							<span style="color: #ffffff; font-weight: bold; font-size: 0.9em !important;">
								‚Ü™ Formed from Run ${formedFrom.fromRun} departing ${previousRunLastLocation}
							</span>
						</div>
					`;
				}
			}
			
			// Now start the main table
			tableHTML += `
				<table class="trip-list-table" style="margin-top: 0;">
					<thead>
						<tr>
							<th>Trip</th>
							<th>From</th>
							<th>Departing</th>
							<th>To</th>
							<th>Arriving</th>
						</tr>
					</thead>
					<tbody>
			`;

			trips.forEach(trip => {
				tableHTML += `
					<tr class="clickable" onclick="displayTrip(${JSON.stringify(trip).replace(/"/g, '&quot;')})">
						<td style="color: #1e88e5; cursor: pointer;">${trip.tripNumber}</td>
						<td>${trip.from}</td>
						<td>${trip.departureTime}</td>
						<td>${trip.to}</td>
						<td>${trip.arrivalTime}</td>
					</tr>
				`;
			});

			// Close the table
			tableHTML += `
					</tbody>
				</table>
			`;

		// Add "Forms Run" message if applicable, AFTER the table as a separate div
			if (runNumber && runTransitions[runNumber]) {
				const nextRun = runTransitions[runNumber].nextRun;
				const location = runTransitions[runNumber].toLocation || runTransitions[runNumber].location;
				
				const timetable = document.getElementById('daySelector').value;
				const nextRunURL = `#timetable=${timetable}&run=${nextRun}`;
				
				tableHTML += `
					<div style="
						display: flex; 
						justify-content: center; 
						align-items: center; 
						cursor: pointer; 
						background-color: #f72f5e; 
						border: 1px solid #424242; 
						padding: 5px; 
						transition: background-color 0.3s; 
						height: 30px;
						margin-top: 0;"
						onclick="window.location.hash='${nextRunURL}'"
						onmouseover="this.style.backgroundColor='#d61c4e'"
						onmouseout="this.style.backgroundColor='#f72f5e'">
						<span style="color: #ffffff; font-weight: bold; font-size: 0.9em !important;">
							‚Ü™ Forms Run ${nextRun} arriving at ${location}
						</span>
					</div>
				`;
			}

			document.getElementById('detailsOutput').innerHTML = tableHTML;
		}

        function updateURLHash() {
            const timetable = document.getElementById('daySelector').value;
            const run = currentRunData ? document.getElementById('currentRun').textContent.split(' ')[1] : null;
            const trip = selectedTrip ? selectedTrip.tripNumber : null;
            
            let hash = `timetable=${timetable}`;
            if (run) hash += `&run=${run}`;
            if (showingAllTimings) hash += '&showall';
            if (trip) hash += `&trip=${trip}`;
            window.location.hash = hash;
        }

        function clearRunSelection() {
            currentRunData = null;
            selectedTrip = null;
            document.getElementById('currentRun').textContent = '';
            document.getElementById('detailsOutput').innerHTML = 'Select a run to view info, or switch to <a href="/search" style="color: #1e88e5; text-decoration: none;">search by location</a> (New!)';
            updateNavigationButtons();
        }
    </script>
	<!-- Cloudflare Web Analytics -->
	<script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "6ec8bf35000f40d799d9a15923996b0f"}'></script>
	<!-- End Cloudflare Web Analytics -->
</body>
</html>
